#!/usr/bin/env node

/**
 * VALIDATION SCRIPT FOR AVAILABILITY CONSISTENCY FIX
 * 
 * Validates that the critical fix for availability inconsistencies
 * between new appointment flow and reschedule modal is working correctly.
 * 
 * @author AgentSalud MVP Team - Critical System Validation
 * @version 1.0.0
 */

const fs = require('fs');
const path = require('path');

console.log('üîç VALIDATING AVAILABILITY CONSISTENCY FIX');
console.log('='.repeat(80));

/**
 * 1. VALIDATE FILE MODIFICATIONS
 */
function validateFileModifications() {
  console.log('\nüìÅ VALIDATING FILE MODIFICATIONS');
  console.log('-'.repeat(50));
  
  const results = {
    unifiedAppointmentFlow: false,
    aiEnhancedRescheduleModal: false,
    errors: []
  };
  
  try {
    // Check UnifiedAppointmentFlow.tsx
    const unifiedFlowPath = path.join(process.cwd(), 'src/components/appointments/UnifiedAppointmentFlow.tsx');
    const unifiedFlowContent = fs.readFileSync(unifiedFlowPath, 'utf8');
    
    // Check for userRole prop
    const hasUserRoleProp = unifiedFlowContent.includes('userRole={userRole}');
    const hasUseStandardRulesProp = unifiedFlowContent.includes('useStandardRules={useStandardRules}');
    
    if (hasUserRoleProp && hasUseStandardRulesProp) {
      results.unifiedAppointmentFlow = true;
      console.log('‚úÖ UnifiedAppointmentFlow.tsx: Props added correctly');
      console.log('   - userRole prop: ‚úÖ');
      console.log('   - useStandardRules prop: ‚úÖ');
    } else {
      results.errors.push('UnifiedAppointmentFlow.tsx missing required props');
      console.log('‚ùå UnifiedAppointmentFlow.tsx: Missing props');
      console.log(`   - userRole prop: ${hasUserRoleProp ? '‚úÖ' : '‚ùå'}`);
      console.log(`   - useStandardRules prop: ${hasUseStandardRulesProp ? '‚úÖ' : '‚ùå'}`);
    }
    
    // Check AIEnhancedRescheduleModal.tsx
    const rescheduleModalPath = path.join(process.cwd(), 'src/components/appointments/AIEnhancedRescheduleModal.tsx');
    const rescheduleModalContent = fs.readFileSync(rescheduleModalPath, 'utf8');
    
    const hasUserRolePropReschedule = rescheduleModalContent.includes('userRole={userRole}');
    const hasUseStandardRulesPropReschedule = rescheduleModalContent.includes('useStandardRules={useStandardRules}');
    
    if (hasUserRolePropReschedule && hasUseStandardRulesPropReschedule) {
      results.aiEnhancedRescheduleModal = true;
      console.log('‚úÖ AIEnhancedRescheduleModal.tsx: Props added correctly');
      console.log('   - userRole prop: ‚úÖ');
      console.log('   - useStandardRules prop: ‚úÖ');
    } else {
      results.errors.push('AIEnhancedRescheduleModal.tsx missing required props');
      console.log('‚ùå AIEnhancedRescheduleModal.tsx: Missing props');
      console.log(`   - userRole prop: ${hasUserRolePropReschedule ? '‚úÖ' : '‚ùå'}`);
      console.log(`   - useStandardRules prop: ${hasUseStandardRulesPropReschedule ? '‚úÖ' : '‚ùå'}`);
    }
    
  } catch (error) {
    results.errors.push(`File validation error: ${error.message}`);
    console.log(`‚ùå Error validating files: ${error.message}`);
  }
  
  return results;
}

/**
 * 2. VALIDATE COMPONENT INTERFACE CONSISTENCY
 */
function validateComponentInterface() {
  console.log('\nüîß VALIDATING COMPONENT INTERFACE CONSISTENCY');
  console.log('-'.repeat(50));
  
  const results = {
    interfaceConsistent: false,
    errors: []
  };
  
  try {
    // Check WeeklyAvailabilitySelector interface
    const selectorPath = path.join(process.cwd(), 'src/components/appointments/WeeklyAvailabilitySelector.tsx');
    const selectorContent = fs.readFileSync(selectorPath, 'utf8');
    
    // Check for userRole and useStandardRules in interface
    const hasUserRoleInterface = selectorContent.includes('userRole?:') || selectorContent.includes('userRole :');
    const hasUseStandardRulesInterface = selectorContent.includes('useStandardRules?:') || selectorContent.includes('useStandardRules :');
    
    if (hasUserRoleInterface && hasUseStandardRulesInterface) {
      results.interfaceConsistent = true;
      console.log('‚úÖ WeeklyAvailabilitySelector interface: Props defined correctly');
      console.log('   - userRole interface: ‚úÖ');
      console.log('   - useStandardRules interface: ‚úÖ');
    } else {
      results.errors.push('WeeklyAvailabilitySelector interface missing prop definitions');
      console.log('‚ùå WeeklyAvailabilitySelector interface: Missing prop definitions');
      console.log(`   - userRole interface: ${hasUserRoleInterface ? '‚úÖ' : '‚ùå'}`);
      console.log(`   - useStandardRules interface: ${hasUseStandardRulesInterface ? '‚úÖ' : '‚ùå'}`);
    }
    
    // Check for prop usage in component
    const hasUserRoleUsage = selectorContent.includes('userRole as ') || selectorContent.includes('userRole,');
    const hasUseStandardRulesUsage = selectorContent.includes('useStandardRules');
    
    if (hasUserRoleUsage && hasUseStandardRulesUsage) {
      console.log('‚úÖ WeeklyAvailabilitySelector usage: Props used correctly');
      console.log('   - userRole usage: ‚úÖ');
      console.log('   - useStandardRules usage: ‚úÖ');
    } else {
      results.errors.push('WeeklyAvailabilitySelector not using props correctly');
      console.log('‚ùå WeeklyAvailabilitySelector usage: Props not used correctly');
      console.log(`   - userRole usage: ${hasUserRoleUsage ? '‚úÖ' : '‚ùå'}`);
      console.log(`   - useStandardRules usage: ${hasUseStandardRulesUsage ? '‚úÖ' : '‚ùå'}`);
    }
    
  } catch (error) {
    results.errors.push(`Interface validation error: ${error.message}`);
    console.log(`‚ùå Error validating interface: ${error.message}`);
  }
  
  return results;
}

/**
 * 3. VALIDATE API PARAMETER CONSISTENCY
 */
function validateAPIParameterConsistency() {
  console.log('\nüåê VALIDATING API PARAMETER CONSISTENCY');
  console.log('-'.repeat(50));
  
  const results = {
    parameterConsistent: false,
    errors: []
  };
  
  try {
    // Check UnifiedAppointmentFlow loadWeeklyAvailability function
    const unifiedFlowPath = path.join(process.cwd(), 'src/components/appointments/UnifiedAppointmentFlow.tsx');
    const unifiedFlowContent = fs.readFileSync(unifiedFlowPath, 'utf8');
    
    const hasUserRoleParam = unifiedFlowContent.includes('userRole=${encodeURIComponent(userRole)}') || 
                            unifiedFlowContent.includes('userRole=${userRole}');
    const hasUseStandardRulesParam = unifiedFlowContent.includes('useStandardRules=${useStandardRules}');
    
    console.log('üìä UnifiedAppointmentFlow API parameters:');
    console.log(`   - userRole parameter: ${hasUserRoleParam ? '‚úÖ' : '‚ùå'}`);
    console.log(`   - useStandardRules parameter: ${hasUseStandardRulesParam ? '‚úÖ' : '‚ùå'}`);
    
    // Check AIEnhancedRescheduleModal loadAvailabilityData function
    const rescheduleModalPath = path.join(process.cwd(), 'src/components/appointments/AIEnhancedRescheduleModal.tsx');
    const rescheduleModalContent = fs.readFileSync(rescheduleModalPath, 'utf8');
    
    const hasUserRoleParamReschedule = rescheduleModalContent.includes('userRole\', userRole') || 
                                      rescheduleModalContent.includes('userRole", userRole');
    const hasUseStandardRulesParamReschedule = rescheduleModalContent.includes('useStandardRules\', useStandardRules') || 
                                              rescheduleModalContent.includes('useStandardRules", useStandardRules');
    
    console.log('üìä AIEnhancedRescheduleModal API parameters:');
    console.log(`   - userRole parameter: ${hasUserRoleParamReschedule ? '‚úÖ' : '‚ùå'}`);
    console.log(`   - useStandardRules parameter: ${hasUseStandardRulesParamReschedule ? '‚úÖ' : '‚ùå'}`);
    
    if (hasUserRoleParam && hasUseStandardRulesParam && 
        hasUserRoleParamReschedule && hasUseStandardRulesParamReschedule) {
      results.parameterConsistent = true;
      console.log('‚úÖ API parameter consistency: Both flows use identical parameters');
    } else {
      results.errors.push('API parameters not consistent between flows');
      console.log('‚ùå API parameter consistency: Parameters differ between flows');
    }
    
  } catch (error) {
    results.errors.push(`API parameter validation error: ${error.message}`);
    console.log(`‚ùå Error validating API parameters: ${error.message}`);
  }
  
  return results;
}

/**
 * 4. GENERATE VALIDATION REPORT
 */
function generateValidationReport(fileResults, interfaceResults, apiResults) {
  console.log('\nüìä VALIDATION REPORT');
  console.log('='.repeat(80));
  
  const allErrors = [
    ...fileResults.errors,
    ...interfaceResults.errors,
    ...apiResults.errors
  ];
  
  const overallSuccess = fileResults.unifiedAppointmentFlow && 
                        fileResults.aiEnhancedRescheduleModal && 
                        interfaceResults.interfaceConsistent && 
                        apiResults.parameterConsistent;
  
  console.log('üéØ VALIDATION SUMMARY:');
  console.log(`   File modifications: ${fileResults.unifiedAppointmentFlow && fileResults.aiEnhancedRescheduleModal ? '‚úÖ PASS' : '‚ùå FAIL'}`);
  console.log(`   Interface consistency: ${interfaceResults.interfaceConsistent ? '‚úÖ PASS' : '‚ùå FAIL'}`);
  console.log(`   API parameter consistency: ${apiResults.parameterConsistent ? '‚úÖ PASS' : '‚ùå FAIL'}`);
  console.log(`   Overall validation: ${overallSuccess ? '‚úÖ PASS' : '‚ùå FAIL'}`);
  
  if (overallSuccess) {
    console.log('\nüéâ SUCCESS: Availability consistency fix has been VALIDATED!');
    console.log('   ‚úÖ All required props are correctly passed to WeeklyAvailabilitySelector');
    console.log('   ‚úÖ Both flows will use identical API parameters');
    console.log('   ‚úÖ Role-based availability logic will be consistent');
    console.log('   ‚úÖ The critical inconsistency issue is RESOLVED');
  } else {
    console.log('\n‚ö†Ô∏è  VALIDATION FAILED: Issues detected with the fix');
    console.log('   Some components are not correctly configured');
    
    if (allErrors.length > 0) {
      console.log('\n‚ùå ERRORS FOUND:');
      allErrors.forEach((error, index) => {
        console.log(`   ${index + 1}. ${error}`);
      });
    }
  }
  
  console.log('\nüîß NEXT STEPS:');
  if (overallSuccess) {
    console.log('1. ‚úÖ Deploy the changes to production');
    console.log('2. ‚úÖ Test both flows in the UI');
    console.log('3. ‚úÖ Monitor for consistent slot counts');
    console.log('4. ‚úÖ Mark the critical issue as RESOLVED');
  } else {
    console.log('1. üîç Review and fix the identified issues');
    console.log('2. üîç Re-run this validation script');
    console.log('3. üîç Ensure all props are correctly passed');
    console.log('4. üîç Verify API parameter consistency');
  }
  
  console.log('\n='.repeat(80));
  
  return {
    success: overallSuccess,
    errors: allErrors,
    timestamp: new Date().toISOString()
  };
}

/**
 * MAIN VALIDATION EXECUTION
 */
function main() {
  console.log('üöÄ Starting availability consistency fix validation...\n');
  
  try {
    // Run all validations
    const fileResults = validateFileModifications();
    const interfaceResults = validateComponentInterface();
    const apiResults = validateAPIParameterConsistency();
    
    // Generate final report
    const report = generateValidationReport(fileResults, interfaceResults, apiResults);
    
    // Exit with appropriate code
    process.exit(report.success ? 0 : 1);
    
  } catch (error) {
    console.error('\n‚ùå VALIDATION SCRIPT ERROR:', error.message);
    console.error('Stack trace:', error.stack);
    process.exit(1);
  }
}

// Run the validation
main();
